- 평가 순서를 미루며 평가 순서를 조작하는 제너레이터 함수이다

- 일반
- qurry 생략

```javascript
const map = qurry((f, iter) => {
  let res = [];
  iter = iter[Symbol.iterator]() // iter가 이터러블에서 이터레이터로 변환된다.
  let cur;

  while(!(cur = iter.next().done)) // for of를 자세히 표기시
    const a = cur.value
    names.push(f(a));
  }

  return res;
});

const filter = qurry((f, iter) => {
  let res = [];
  iter = iter[Symbol.iterator]()
  let cur;

  while(!(cur = iter.next().done)) // for of를 자세히 표기시
    const a = cur.value
    if(f(a)) res.push(a)
  }
});

const take = qurry((l, iter) => {
  let res = [];
  iter = iter[Symbol.iterator]()
  let cur;

  while(!(cur = iter.next()).done){
    const a = cur.value
    res.push(a);
    if (res.length === l) {
      return res;
    }
  }

  return res;
});



go(
  range(10),
  map((n) => n + 10),
  filter((n) => n % 2),
  take(2),
  log
);
```

- 느긋한
- qurry 생략

```javascript
L.map = qurry(function* (iter) {
  iter = iter[Symbol.iterator]();
  let cur;

  while (!(cur = iter.next()).done) {
    const a = cur.value;
    yield a;
  }
});

L.filter = qurry(function* (f, iter) {
  iter = iter[Symbol.iterator]();
  let cur;

  while (!(cur = iter.next()).done) {
    const a = cur.value;
    if (f(a)) yield a;
  }
});

L.range = qurry(function *(l) => {
  console.log('hi~') // 첫 .next()실행 시만 실행된다.
  let i = -1;
  while (++i < l) {
    console.log(i)
    yield i
  }
});

const reduce = qurry((f, acc, iter) => {
  if (!iter) {
    iter = acc[Symbol.iterator]();
    acc = iter.next().value;
  } else {
    iter = acc[Symbol.iterator]();
  }
  iter = iter[Symbol.iterator]();
  let cur;

  while (!(cur = iter.next()).done) {
    const a = cur.value;
    acc = f(acc, a);
  }
  return acc;
});


go(
  L.range(10),
  L.map((n) => n + 10),
  L.filter((n) => n % 2),
  take(2),
  log
);
```
